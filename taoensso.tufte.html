<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>taoensso.tufte documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Tufte</span> <span class="project-version">1.1.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>taoensso</span></div></div></li><li class="depth-2 current"><a href="taoensso.tufte.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tufte</span></div></a></li><li class="depth-3 branch"><a href="taoensso.tufte.examples.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>examples</span></div></a></li><li class="depth-3 branch"><a href="taoensso.tufte.impl.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>impl</span></div></a></li><li class="depth-3"><a href="taoensso.tufte.timbre.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>timbre</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="taoensso.tufte.html#var-*min-level*"><div class="inner"><span>*min-level*</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-*ns-filter*"><div class="inner"><span>*ns-filter*</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var--compile-ns-filter"><div class="inner"><span>-compile-ns-filter</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var--elide.3F"><div class="inner"><span>-elide?</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-accounted-time"><div class="inner"><span>accounted-time</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-accumulate-stats"><div class="inner"><span>accumulate-stats</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-add-basic-println-handler.21"><div class="inner"><span>add-basic-println-handler!</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-add-handler.21"><div class="inner"><span>add-handler!</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-chance"><div class="inner"><span>chance</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-compile-ns-filter"><div class="inner"><span>compile-ns-filter</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-defnp"><div class="inner"><span>defnp</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-fnp"><div class="inner"><span>fnp</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-format-stats"><div class="inner"><span>format-stats</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-handlers_"><div class="inner"><span>handlers_</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-may-profile.3F"><div class="inner"><span>may-profile?</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-merge-stats"><div class="inner"><span>merge-stats</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-p"><div class="inner"><span>p</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-profile"><div class="inner"><span>profile</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-profiled"><div class="inner"><span>profiled</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-profiling.3F"><div class="inner"><span>profiling?</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-pspy"><div class="inner"><span>pspy</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-refer-tufte"><div class="inner"><span>refer-tufte</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-remove-handler.21"><div class="inner"><span>remove-handler!</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-set-min-level.21"><div class="inner"><span>set-min-level!</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-set-ns-pattern.21"><div class="inner"><span>set-ns-pattern!</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-start-profiling-thread.21"><div class="inner"><span>start-profiling-thread!</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-stats-accumulator"><div class="inner"><span>stats-accumulator</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-stop-profiling-thread.21"><div class="inner"><span>stop-profiling-thread!</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-valid-min-level"><div class="inner"><span>valid-min-level</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-valid-min-level.3F"><div class="inner"><span>valid-min-level?</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-valid-run-level"><div class="inner"><span>valid-run-level</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-valid-run-level.3F"><div class="inner"><span>valid-run-level?</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-with-min-level"><div class="inner"><span>with-min-level</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-with-ns-pattern"><div class="inner"><span>with-ns-pattern</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">taoensso.tufte</h1><div class="doc"><pre class="plaintext">A simple, fast, monitoring profiler for Clojure/Script.

Usage: wrap+name interesting body exprs with the `p` macro. Then activate
profiling of these wrapped exprs using the `profiled` or `profile` macros:

  (profiled {} (p :my-fn (my-fn))) ; Returns [&lt;body-result&gt; &lt;?stats-map&gt;]
  (profile  {} (p :my-fn (my-fn))) ; Returns  &lt;body-result&gt;, dispatches
                                   ; ?stats-map to any registered handlers.

Extensive facilities are provided for compile-time elision and runtime
filtering.

See the relevant docstrings for more info:
  `p`, `profiled`, `profile`, `add-handler!` ; Core API

  (p        [opts &amp; body] [id &amp; body]) ; e.g. `(p ::my-pid (do-work))`
  (profiled [opts &amp; body])             ; e.g. `(profiled {:level 2} (my-fn))`
  (profile  [opts &amp; body])             ; e.g. `(profiled {:level 2} (my-fn))`

  (add-handler! [handler-id ns-pattern handler-fn])

How/where to use this library:
  Tufte is highly optimized: even without elision, you can usually leave
  profiling code in production (e.g. for sampled profiling, or to detect
  unusual performance behaviour). Tufte's stats maps are well suited to
  programmatic inspection + analysis.</pre></div><div class="public anchor" id="var-*min-level*"><h3>*min-level*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><pre class="plaintext">e/o #{0 1 2 3 4 5 6}
</pre></div></div><div class="public anchor" id="var-*ns-filter*"><h3>*ns-filter*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><pre class="plaintext">(fn [?ns] -&gt; truthy).
</pre></div></div><div class="public anchor" id="var--compile-ns-filter"><h3>-compile-ns-filter</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var--elide.3F"><h3>-elide?</h3><div class="usage"><code>(-elide? level-form ns-str-form)</code></div><div class="doc"><pre class="plaintext">Returns true iff level or ns are compile-time filtered.
</pre></div></div><div class="public anchor" id="var-accounted-time"><h3>accounted-time</h3><div class="usage"><code>(accounted-time stats)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-accumulate-stats"><h3>accumulate-stats</h3><div class="usage"><code>(accumulate-stats stats-accumulator [profiled-result profiled-?stats])</code></div><div class="doc"><pre class="plaintext">Experimental, subject to change!
</pre></div></div><div class="public anchor" id="var-add-basic-println-handler.21"><h3>add-basic-println-handler!</h3><div class="usage"><code>(add-basic-println-handler! {:keys [ns-pattern], :or {ns-pattern "*"}})</code></div><div class="doc"><pre class="plaintext">Adds a simple handler that logs `profile` stats output with `println`.
</pre></div></div><div class="public anchor" id="var-add-handler.21"><h3>add-handler!</h3><div class="usage"><code>(add-handler! handler-id handler-fn)</code><code>(add-handler! handler-id ns-pattern handler-fn)</code></div><div class="doc"><pre class="plaintext">Use this to register interest in stats output produced by `profile` calls.
Each registered `handler-fn` will be called as:

  (handler-fn {:ns-str _ :level _ :?id _ :?data _ :stats _ :stats-str_ _})

Map args:
  :ns-str     - Namespace string where `profile` call took place
  :level      - Level e/o #{0 1 2 3 4 5}, given in `(profile {:level _} ...)`
  :?id        - Optional id,              given in `(profile {:id    _} ...)`
  :?data      - Optional arb data,        given in `(profile {:data  _} ...)`
  :stats      - Stats map as in `(second (profiled ...))`
  :stats-str_ - `(delay (format-stats stats))`

Error handling (NB):
  Handler errors will be silently swallowed. Please `try`/`catch` and
  appropriately deal with (e.g. log) possible errors *within* `handler-fn`.

Async/blocking:
  `handler-fn` should ideally be non-blocking, or reasonably cheap. Handler
   dispatch occurs through a 1-thread 1k-buffer dropping queue.

Ns filtering:
  Provide an optional `ns-pattern` arg to only call handler for matching
  namespaces. See `compile-ns-filter` docstring for details on `ns-pattern`.

Handler ideas:
  Save to a db, log, `put!` to an appropriate `core.async` channel, filter,
  aggregate, use for a realtime analytics dashboard, examine for outliers
  or unexpected output, ...</pre></div></div><div class="public anchor" id="var-chance"><h3>chance</h3><div class="usage"><code>(chance p)</code></div><div class="doc"><pre class="plaintext">Returns true with 0&lt;`p`&lt;1 probability.
</pre></div></div><div class="public anchor" id="var-compile-ns-filter"><h3>compile-ns-filter</h3><div class="usage"><code>(compile-ns-filter ns-pattern)</code></div><div class="doc"><pre class="plaintext">Returns (fn [?ns]) -&gt; truthy. Some example patterns:
"foo.bar", "foo.bar.*", #{"foo" "bar"},
{:whitelist ["foo.bar.*"] :blacklist ["baz.*"]}</pre></div></div><div class="public anchor" id="var-defnp"><h3>defnp</h3><h4 class="type">macro</h4><div class="usage"><code>(defnp name doc-string? attr-map? [params*] prepost-map? body)</code><code>(defnp name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?)</code></div><div class="doc"><pre class="plaintext">Like `defn` but wraps fn bodies with `p` macro.
</pre></div></div><div class="public anchor" id="var-fnp"><h3>fnp</h3><h4 class="type">macro</h4><div class="usage"><code>(fnp name? [params*] prepost-map? body)</code><code>(fnp name? ([params*] prepost-map? body) +)</code></div><div class="doc"><pre class="plaintext">Like `fn` but wraps fn bodies with `p` macro.
</pre></div></div><div class="public anchor" id="var-format-stats"><h3>format-stats</h3><div class="usage"><code>(format-stats stats)</code><code>(format-stats stats sort-fn)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-handlers_"><h3>handlers_</h3><div class="usage"></div><div class="doc"><pre class="plaintext">{&lt;handler-id&gt; &lt;handler-fn&gt;}
</pre></div></div><div class="public anchor" id="var-may-profile.3F"><h3>may-profile?</h3><div class="usage"><code>(may-profile? level)</code><code>(may-profile? level ns)</code></div><div class="doc"><pre class="plaintext">Returns true iff level and ns are runtime unfiltered.
</pre></div></div><div class="public anchor" id="var-merge-stats"><h3>merge-stats</h3><div class="usage"><code>(merge-stats s1 s2)</code></div><div class="doc"><pre class="plaintext">Merges stats maps from multiple runs or threads.
Automatically identifies and merges concurrent time windows.</pre></div></div><div class="public anchor" id="var-p"><h3>p</h3><h4 class="type">macro</h4><div class="usage"><code>(p id &amp; body)</code><code>(p opts &amp; body)</code></div><div class="doc"><pre class="plaintext">Profiling spy. Always executes body, and always returns &lt;body-result&gt;.

When [ns level] unelided and profiling is active, records execution
time of body.

Compile-time opts:
 :id    - Id for this body in stats output (e.g. `::my-fn-call`)
 :level - e/o #{0 1 2 3 4 5} ; Default is `5`</pre></div></div><div class="public anchor" id="var-profile"><h3>profile</h3><h4 class="type">macro</h4><div class="usage"><code>(profile opts &amp; body)</code></div><div class="doc"><pre class="plaintext">Always executes body, and always returns &lt;body-result&gt;.

When [ns level] unelided and [ns level `when`] unfiltered, executes body
with profiling active and dispatches stats to any registered handlers
(see `add-handler!`).

Handy if you'd like to consume/aggregate stats output later/elsewhere.
Otherwise see `profiled`.

Compile-time opts:
  :level    - e/o #{0 1 2 3 4 5} ; Default is `5`
  :dynamic? - Use multi-threaded profiling? ; Default is `false`
  :when     - Optional arbitrary conditional form (e.g. boolean expr)
  :id       - Optional stats id provided to handlers (e.g. `::my-stats-1`)
  :data     - Optional, any other arbitrary data provided to handlers</pre></div></div><div class="public anchor" id="var-profiled"><h3>profiled</h3><h4 class="type">macro</h4><div class="usage"><code>(profiled opts &amp; body)</code></div><div class="doc"><pre class="plaintext">Always executes body, and always returns [&lt;body-result&gt; ?&lt;stats&gt;].

When [ns level] unelided and [ns level `when`] unfiltered, executes body
with profiling active.

Handy if you'd like to consume stats output directly.
Otherwise see `profile`.

Compile-time opts:
  :level    - e/o #{0 1 2 3 4 5} ; Default is `5`
  :dynamic? - Use multi-threaded profiling? ; Default is `false`
  :when     - Optional arbitrary conditional form (e.g. boolean expr)</pre></div></div><div class="public anchor" id="var-profiling.3F"><h3>profiling?</h3><div class="usage"><code>(profiling?)</code></div><div class="doc"><pre class="plaintext">Returns e/o #{nil :thread :dynamic}.
</pre></div></div><div class="public anchor" id="var-pspy"><h3>pspy</h3><h4 class="type">macro</h4><div class="usage"><code>(pspy &amp; args)</code></div><div class="doc"><pre class="plaintext">`p` alias
</pre></div></div><div class="public anchor" id="var-refer-tufte"><h3>refer-tufte</h3><div class="usage"><code>(refer-tufte)</code></div><div class="doc"><pre class="plaintext">(require '[taoensso.tufte :as tufte :refer [defnp p profiled profile]])
</pre></div></div><div class="public anchor" id="var-remove-handler.21"><h3>remove-handler!</h3><div class="usage"><code>(remove-handler! handler-id)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-set-min-level.21"><h3>set-min-level!</h3><div class="usage"><code>(set-min-level! level)</code></div><div class="doc"><pre class="plaintext">Sets root binding of minimum profiling level, e/o #{0 1 2 3 4 5 6}.
0 =&gt; Enable  all profiling.
6 =&gt; Disable all profiling.</pre></div></div><div class="public anchor" id="var-set-ns-pattern.21"><h3>set-ns-pattern!</h3><div class="usage"><code>(set-ns-pattern! ns-pattern)</code></div><div class="doc"><pre class="plaintext">Sets root binding of namespace filter.
See `compile-ns-filter` docstring for details on `ns-pattern` arg.</pre></div></div><div class="public anchor" id="var-start-profiling-thread.21"><h3>start-profiling-thread!</h3><div class="usage"><code>(start-profiling-thread!)</code></div><div class="doc"><pre class="plaintext">Warning: this is a low-level primitive. Prefer higher-level macros
like `profile` when possible.

NB: must be accompanied by a call to `stop-profiling-thread!`
(e.g. using `try`/`finally`).</pre></div></div><div class="public anchor" id="var-stats-accumulator"><h3>stats-accumulator</h3><div class="usage"><code>(stats-accumulator)</code></div><div class="doc"><pre class="plaintext">Experimental, subject to change!
Small util to help merge stats maps from multiple runs or threads.
Returns a stateful fn with arities:
  ([stats]) ; Accumulates the given stats (you may call this from any thread)
  ([])      ; Deref: returns the merged value of all accumulated stats</pre></div></div><div class="public anchor" id="var-stop-profiling-thread.21"><h3>stop-profiling-thread!</h3><div class="usage"><code>(stop-profiling-thread!)</code></div><div class="doc"><pre class="plaintext">Warning: this is a low-level primitive.
</pre></div></div><div class="public anchor" id="var-valid-min-level"><h3>valid-min-level</h3><div class="usage"><code>(valid-min-level x)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-valid-min-level.3F"><h3>valid-min-level?</h3><div class="usage"><code>(valid-min-level? x)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-valid-run-level"><h3>valid-run-level</h3><div class="usage"><code>(valid-run-level x)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-valid-run-level.3F"><h3>valid-run-level?</h3><div class="usage"><code>(valid-run-level? x)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-with-min-level"><h3>with-min-level</h3><h4 class="type">macro</h4><div class="usage"><code>(with-min-level level &amp; body)</code></div><div class="doc"><pre class="plaintext">Executes body with dynamic minimum profiling level, e/o #{0 1 2 3 4 5 6}.
0 =&gt; Enable  all profiling.
6 =&gt; Disable all profiling.</pre></div></div><div class="public anchor" id="var-with-ns-pattern"><h3>with-ns-pattern</h3><h4 class="type">macro</h4><div class="usage"><code>(with-ns-pattern ns-pattern &amp; body)</code></div><div class="doc"><pre class="plaintext">Executes body with dynamic namespace filter.
See `compile-ns-filter` docstring for details on `ns-pattern` arg.</pre></div></div></div></body></html>